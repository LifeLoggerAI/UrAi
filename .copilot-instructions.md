# ðŸ§  Copilot Mega-Prompt: "URAI Demo-Ready Hardening & Wiring"

You are my senior engineer. Apply the following repo-wide plan to make URAI build cleanly, run a beautiful demo without heavy assets, and ship one working narrator flow with seeded timeline stars.

## Objectives (acceptance criteria)

âœ… npm run build succeeds with zero errors (warnings ok).

âœ… App loads a HomeView with layered sky / ground / avatar using tiny placeholder mp4s (no huge assets in Git).

âœ… Route /u/[handle] shows a seeded timeline of 10â€“20 stars and 2â€“3 memory blooms.

âœ… One narrator chat flow works: text in â†’ assistant reply out (mock or real).

âœ… One forecast doc and one weekly reflection doc display in UI (can be generated by a mock cron function).

âœ… Types are unified (central zod schemas + TypeScript types), imports via @/* path alias.

âœ… Asset strategy: heavy loops not in repo; .gitignore blocks large assets; code supports CDN/public bucket later.

## 0) Repo hygiene

Add/update .gitignore to keep the repo light:

```gitignore
# build & caches
.next/
.turbo/
dist/
coverage/
# deps
node_modules/
# local env
.env
.env.*
# heavy assets (keep out of git)
public/assets/sky/**/*.mp4
public/assets/ground/**/*.mp4
public/assets/avatar/**/*.mp4
public/assets/**/*.mov
*.zip
*.mp4
*.mov
```

Add placeholder tiny loops (few KB) so the UI works:
- public/placeholders/sky.mp4
- public/placeholders/ground.mp4
- public/placeholders/avatar.mp4

If these don't exist, auto-generate simple 1â€“2s blank mp4s or swap to <div> fallback.

## 1) Type & schema unification

Create src/ai/schemas/chat.ts and centralize message types:

```typescript
// src/ai/schemas/chat.ts
import { z } from "zod";

export const ChatMessageSchema = z.object({
  role: z.enum(["system", "user", "assistant"]),
  content: z.string(),
  timestamp: z.number().optional(),
  meta: z.record(z.any()).optional(),
});
export type ChatMessage = z.infer<typeof ChatMessageSchema>;

export const CompanionChatOutputSchema = z.object({
  reply: z.string(),
  moodTag: z.string().optional(),
  insights: z.array(z.string()).optional(),
});
export type CompanionChatOutput = z.infer<typeof CompanionChatOutputSchema>;
```

Refactor any usage to import from @/ai/schemas/chat.

## 2) Fix Next/PostCSS config issues

Remove invalid experimental key on Next 15. Ensure PostCSS config matches module type.

```javascript
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  // experimental: { appDir: true }  // REMOVE if present
};
export default nextConfig;

// postcss.config.mjs (ESM)
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
```

If using CJS instead, rename to postcss.config.cjs and use module.exports = { ... }.

## 3) TS path aliases & strictness

Ensure path alias and strict mode:

```json
// tsconfig.json (or tsconfig.app.json)
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "strict": true,
    "noImplicitAny": true,
    "skipLibCheck": true
  }
}
```

Run tsc --noEmit clean.

## 4) Companion chat flow (minimal working)

Create/repair src/ai/flows/companion-chat.ts:

```typescript
import { z } from "zod";
import { ChatMessageSchema, CompanionChatOutputSchema } from "@/ai/schemas/chat";

// Simple in-process handler stub (replace with your AI provider later)
export const companionPrompt = {
  name: "companionPrompt",
  input: z.object({
    history: z.array(ChatMessageSchema).default([]),
    message: z.string(),
  }),
  output: CompanionChatOutputSchema,
  async run({ history, message }: z.infer<typeof this["input"]) {
    const reply =
      "âœ¨ I'm listening. Here's a gentle reflection on what you shared, and one small nudge forward.";
    return { reply, moodTag: "calm", insights: ["You're trending toward focus today."] };
  },
};
```

Expose a Next route handler:

```typescript
// src/app/api/companion/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { ChatMessageSchema } from "@/ai/schemas/chat";

const Input = z.object({
  history: z.array(ChatMessageSchema).default([]),
  message: z.string(),
});

export async function POST(req: Request) {
  const json = await req.json();
  const { history, message } = Input.parse(json);
  const reply =
    "âœ¨ I'm listening. Here's a gentle reflection on what you shared, and one small nudge forward.";
  return NextResponse.json({ reply, moodTag: "calm", insights: ["You're trending toward focus today."] });
}
```

## 5) HomeView: layered placeholders & alt props

Create/repair src/app/home-view.tsx with robust fallbacks and a11y:

```typescript
// src/app/home-view.tsx
import React from "react";

const srcSky = "/placeholders/sky.mp4";
const srcGround = "/placeholders/ground.mp4";
const srcAvatar = "/placeholders/avatar.mp4";

export default function HomeView() {
  return (
    <main className="relative h-dvh w-full overflow-hidden bg-black">
      {/* SKY */}
      <video
        className="absolute inset-0 h-full w-full object-cover z-0"
        src={srcSky}
        autoPlay
        loop
        muted
        playsInline
        aria-label="Sky layer animation"
      />
      {/* GROUND */}
      <video
        className="absolute inset-0 h-full w-full object-cover z-10"
        src={srcGround}
        autoPlay
        loop
        muted
        playsInline
        aria-label="Ground layer animation"
      />
      {/* AVATAR */}
      <video
        className="absolute inset-0 h-full w-full object-contain z-20 pointer-events-none"
        src={srcAvatar}
        autoPlay
        loop
        muted
        playsInline
        aria-label="Avatar layer animation"
      />
      {/* HUD */}
      <div className="absolute bottom-4 left-4 z-30 rounded-2xl bg-white/5 backdrop-blur px-4 py-3 text-white">
        <div className="text-sm opacity-80">Mood Forecast</div>
        <div className="text-lg">Calm â€¢ Focus rising</div>
      </div>
    </main>
  );
}
```

Make sure any <img> tags in the project have alt (use alt="" if decorative).

## 6) Demo route with seeded stars

Create a simple seeded view for /u/[handle]:

```typescript
// src/app/u/[handle]/page.tsx
import React from "react";

type Star = { id: string; t: string; tag?: string; detail?: string };
const seeded: Star[] = Array.from({ length: 14 }).map((_, i) => ({
  id: `s${i}`,
  t: new Date(Date.now() - i * 86400000).toISOString(),
  tag: i % 3 === 0 ? "recovery" : i % 3 === 1 ? "focus" : "social",
  detail: ["A small win", "A calm walk", "A tough moment re-framed"][i % 3],
}));

export default function UserDemo({ params }: { params: { handle: string } }) {
  return (
    <div className="min-h-dvh bg-black text-white p-6 space-y-6">
      <h1 className="text-2xl">@{params.handle} â€¢ Star Timeline</h1>
      <ul className="grid grid-cols-2 md:grid-cols-3 gap-3">
        {seeded.map((s) => (
          <li key={s.id} className="rounded-2xl bg-white/5 p-4">
            <div className="text-sm opacity-70">{new Date(s.t).toDateString()}</div>
            <div className="text-lg">{s.detail}</div>
            <div className="text-xs opacity-60">{s.tag}</div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

## 7) Forecast & weekly reflection docs (mock cron)

Create a minimal Firebase Function (if functions exist) or an in-app cron mock. If using Cloud Functions:

```typescript
// functions/src/scheduled/seedForecast.ts
import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
admin.initializeApp();

export const seedForecast = functions.pubsub
  .schedule("every 24 hours")
  .onRun(async () => {
    const db = admin.firestore();
    const now = new Date().toISOString();
    await db.collection("forecasts").doc("demo").set({
      createdAt: now,
      summary: "Calm with rising focus; social energy mid.",
    });
    await db.collection("weeklyReflections").doc("demo").set({
      weekOf: now.slice(0, 10),
      highlights: ["Recovered after dip", "Noticed focus streak", "Reached out to a friend"],
    });
    return null;
  });
```

In the app, add a tiny component to read and show these docs with graceful fallbacks.

## 8) Minimal UI to call the narrator API

```typescript
// src/components/CompanionChat.tsx
"use client";
import React, { useState } from "react";

export default function CompanionChat() {
  const [text, setText] = useState("");
  const [reply, setReply] = useState<string | null>(null);

  const send = async () => {
    const res = await fetch("/api/companion", {
      method: "POST",
      body: JSON.stringify({ history: [], message: text }),
      headers: { "Content-Type": "application/json" },
    });
    const json = await res.json();
    setReply(json.reply ?? "â€¦");
  };

  return (
    <div className="rounded-2xl bg-white/5 p-4 text-white space-y-3">
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Tell me what's on your mindâ€¦"
        className="w-full rounded-xl bg-white/10 px-3 py-2 outline-none"
        aria-label="Companion message input"
      />
      <button onClick={send} className="rounded-xl bg-white/20 px-3 py-2">
        Send
      </button>
      {reply && <div className="text-sm opacity-90">Assistant: {reply}</div>}
    </div>
  );
}
```

Render this in HomeView or a /demo page.

## 9) Scripts & linting

Add npm scripts to help me test quickly:

```json
// package.json (add or ensure)
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "typecheck": "tsc --noEmit",
    "lint": "eslint \"src/**/*.{ts,tsx}\" --fix"
  }
}
```

Run these locally and confirm clean:
- npm run typecheck
- npm run build
- npm run start

## 10) Optional CI (skip if repo already has it)

```yaml
# .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - run: npm ci
      - run: npm run typecheck
      - run: npm run build
```

## 11) Final polish checklist (Copilot, verify these)

- Replace any remaining <img> missing alt.
- Ensure no imports use broken paths; convert to @/*.
- Confirm home-view.tsx and /u/[handle] route render without data.
- Confirm /api/companion returns a JSON reply.
- Confirm placeholder videos load and loop without blocking the main thread.
- Ensure there's no dependency on heavy assets; app is demo-friendly out of the box.

## Commits

Create small, clear commits:
- chore(config): clean next/postcss and ts paths
- feat(ai): unify chat schemas and companion flow
- feat(ui): HomeView layered placeholders
- feat(demo): seeded /u/[handle] timeline
- feat(api): /api/companion minimal handler
- feat(functions): mock forecast & weekly reflection cron
- chore(repo): gitignore heavy assets, add placeholders
- chore(ci): add basic build workflow

Do all of the above now. If a file already exists, refactor in place; otherwise create it. Keep code clean, minimal, and production-friendly.